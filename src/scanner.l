%option debug
%option c++
%option noyywrap
%option never-interactive
%option yylineno
%option nounput
%option batch
%option prefix="yy"
%option stack
%option nodefault
%option warn
%option nounistd
%option yyclass="Scanner"

%top{
// This block is inserted at the top of scanner.yy.cc

// Disable compiler-specific warnings for code generated by Flex
#if defined(__clang__)
#    pragma clang diagnostic push
#    pragma clang diagnostic ignored "-Wunknown-pragmas"
#    pragma clang diagnostic ignored "-Wunknown-warning-option"
#    pragma clang diagnostic ignored "-Wmisleading-indentation"
#elif defined(__GNUC__) || defined(__GNUG__)
#    pragma GCC diagnostic push
#    pragma GCC diagnostic ignored "-Wsuggest-override"
#elif defined(_MSC_VER)
#    pragma warning(push)
#    pragma warning(disable : 4101)
#    pragma warning(disable : 4244)
#    pragma warning(disable : 4244)
#    pragma warning(disable : 6011)
#    include <stdint.h>
#endif

#include <algorithm>
#include <cctype>
#include <cmath>
#include <sstream>

#include "driver.h"

}

%{

#include "scanner.h"
class yyFlexLexer;

#define STEP()                                                          \
    do {                                                                \
        driver.location->step();                                        \
    } while (0)

#define COL(col)                                                        \
    driver.location->columns(col)

#define LINE()                                                          \
    do {                                                                \
        auto lines = std::count(yytext, yytext + yyleng, '\n');         \
        driver.location->lines(lines);                                  \
        driver.lines.insert(driver.lines.end(), lines, "");             \
        STEP();                                                         \
    } while (0)

#define YY_USER_ACTION  {                                               \
        STEP();                                                         \
        COL(yyleng);                                                    \
        driver.lines.back() += yytext;                                  \
    }

#define LOC                                                             \
    (*driver.location)

#define PUSH(TOKEN)                                                     \
    do {                                                                \
        driver.tokenQ.emplace(TOKEN);                                   \
        if (yy_flex_debug) {                                            \
            const auto &tok = driver.tokenQ.back();                     \
            std::cerr << "--pushing \"" << tok.name() << "\" (";        \
            if (tok.location.begin.filename)                            \
                std::cerr << *tok.location.begin.filename << ":";       \
            std::cerr << tok.location.begin.line << ":";                \
            std::cerr << tok.location.begin.column << " - ";            \
            std::cerr << tok.location.end.line << ":";                  \
            std::cerr << tok.location.end.column << ")" << std::endl;   \
        }                                                               \
    } while(0)

#define POP_TOKEN()                                                     \
    do {                                                                \
        if (driver.tokenQ.size() > 1) {                                 \
            /* Don't pop the last token in the queue, it is needed */   \
            /* for the EOF rule. */                                     \
            auto tok = std::move(driver.tokenQ.front());                \
            driver.tokenQ.pop();                                        \
            if (yy_flex_debug) {                                        \
                std::cerr << "--popping \"" << tok.name() << "\" (";    \
                if (tok.location.begin.filename)                        \
                    std::cerr << *tok.location.begin.filename << ":";   \
                std::cerr << tok.location.begin.line << ":";            \
                std::cerr << tok.location.begin.column << " - ";        \
                std::cerr << tok.location.end.line << ":";              \
                std::cerr << tok.location.end.column << ")";            \
                std::cerr << std::endl;                                 \
            }                                                           \
            return tok;                                                 \
        }                                                               \
    } while (0)

#define PUSH_TOKEN(TOK)                                                 \
    PUSH(yy::Parser::make_##TOK(*driver.location))

#define PUSH_VALUE(TOK, value)                                          \
    PUSH(yy::Parser::make_##TOK(value, *driver.location))

#define PUSH_TOKEN_AND_POP(TOK)                                         \
    do {                                                                \
        PUSH_TOKEN(TOK);                                                \
        POP_TOKEN();                                                    \
    } while (0)

#define PUSH_VALUE_AND_POP(TOK, value)                                  \
    do {                                                                \
        PUSH_VALUE(TOK, value);                                         \
        POP_TOKEN();                                                    \
    } while (0)

#define LEX_FLOAT()                                                     \
    do {                                                                \
        try {                                                           \
            PUSH_VALUE(FLOAT, std::stod(yytext));                       \
        } catch (const std::out_of_range &e) {                          \
            throw yy::Parser::syntax_error(                             \
                LOC,                                                    \
                std::string{"float is out of range: "} + yytext);       \
        } catch (const std::invalid_argument &e) {                      \
            throw yy::Parser::syntax_error(                             \
                LOC,                                                    \
                std::string{"invalid float: "} + yytext);               \
        }                                                               \
        POP_TOKEN();                                                    \
    } while(0)

#define LEX_INT()                                                       \
    do {                                                                \
        try {                                                           \
            PUSH_VALUE(INT, std::stoll(yytext));                        \
        } catch (const std::out_of_range &e) {                          \
            throw yy::Parser::syntax_error(                             \
                LOC,                                                    \
                std::string{"int is out of range: "} + yytext);         \
        } catch (const std::invalid_argument &e) {                      \
            throw yy::Parser::syntax_error(                             \
                LOC,                                                    \
                std::string{"invalid int: "} + yytext);                 \
        }                                                               \
        POP_TOKEN();                                                    \
    } while(0)

%}

%s PAREN
%x COMMENT

reserved  [=|?<>\\]
op        [+\-*/%&!@#$^~]
id_start  [a-zA-Z]
id        [_0-9]|{id_start}
str       \"([^\\\"\n]|\\.)*\"
exp       [eE][+-]?[[:digit:]]+
nan       (?i:nan)
inf       (?i:inf)

%%

%{
    // This block is executed every time yylex() is called.
    if (driver.tokenQ.size() > 1) {
        // Pop extra tokens if the queue is backed up.
        // Don't pop the last token because it's needed for the <<EOF>> rule.
        POP_TOKEN();
    }
%}

^[ \t\n\r]*[\n\r]/. {
    // Ignore empty lines
    LINE();
}
^[[:blank:]]*"//".*[\n\r]+ {
    // Ignore lines with just comments
    LINE();
}
[\\][[:blank:]]*[\n\r]+ {
    // Dont output escaped newlines
    LINE();
}

[[:blank:]]*"/*" {
    STEP();
    yy_push_state(COMMENT);
}
"*/"        throw yy::Parser::syntax_error(LOC, "unexpected */ outside of block comment");
<COMMENT>{
    "/*"  {
        STEP();
        yy_push_state(COMMENT);
    }
    "*/"[[:blank:]]*[\n\r] {
        LINE();
        yy_pop_state();
    }
    "*/"[[:blank:]]*/[^ \t] {
        STEP();
        if (yy_top_state() != COMMENT) {
            // "*/" can only have non-whitespace characters trailing it if it's inside another block comment.
            throw yy::Parser::syntax_error(LOC, "block comment */ must be followed by a line break");
        }
        yy_pop_state();
    }
    "*/"[[:blank:]\n\r]* {
        // Handle the case where "*/" is followed by EOF
        STEP();
        yy_pop_state();
    }
    [^*/]+ {
        LINE();
    }
    . {
        STEP();
    }
    <<EOF>> {
        throw yy::Parser::syntax_error(LOC, "unexpected EOF in block comment");
    }
}

<PAREN>{
    ")" {
        yy_pop_state();
        PUSH_TOKEN_AND_POP(RPAREN);
    }
    [\n\r]+/. {
        LINE();
    }
    [\n\r \t]+ {
        LINE();
    }
}


^[ ]+[\t] {
    throw Parser::syntax_error(LOC, "inconsistent use of tabs and spaces in indentation");
}
^[\t]+[ ] {
    throw Parser::syntax_error(LOC, "inconsistent use of tabs and spaces in indentation");
}
^[ ]+/([^ ]|\n|\r) {
    if (driver.indentType == Driver::IndentType::NOT_SET) {
        driver.indentType = Driver::IndentType::SPACES;
    } else if (driver.indentType != Driver::IndentType::SPACES) {
        throw Parser::syntax_error(LOC, "inconsistent use of tabs and spaces in indentation");
    }
    if (driver.applyIndent(yyleng)) {
        throw Parser::syntax_error(LOC, "indentation does not match any previous indentation levels");
    }
    if (yy_flex_debug) {
        std::cerr << "--applied indent of " << yyleng << std::endl;
    }
}
^[\t]+/([^\t]|\n|\r) {
    if (driver.indentType == Driver::IndentType::NOT_SET) {
        driver.indentType = Driver::IndentType::TABS;
    } else if (driver.indentType != Driver::IndentType::TABS) {
        throw Parser::syntax_error(LOC, "inconsistent use of tabs and spaces in indentation");
    }
    if (driver.applyIndent(yyleng)) {
        throw Parser::syntax_error(LOC, "indentation does not match any previous indentation levels");
    }
    if (yy_flex_debug) {
        std::cerr << "--applied indent of " << yyleng << std::endl;
    }
}
^[\t ]+ {
    // Match trailing whitespace followed by EOF.
    // The two rules above match any sequence of whitespace followed by a trailing context of any non-EOF character.
    // Therefore this rule matches what's left over, which must be whitespace followed by EOF.
}


"//".* {
    // Ignore comments
    STEP();
}

"var"       PUSH_TOKEN_AND_POP(VAR);
"func"      PUSH_TOKEN_AND_POP(FUNC);
"->"        PUSH_TOKEN_AND_POP(ARROW);
"if"        PUSH_TOKEN_AND_POP(IF);
"then"      PUSH_TOKEN_AND_POP(THEN);
"else"      PUSH_TOKEN_AND_POP(ELSE);
"while"     PUSH_TOKEN_AND_POP(WHILE);
"do"        PUSH_TOKEN_AND_POP(DO);
"match"     PUSH_TOKEN_AND_POP(MATCH);
"case"      PUSH_TOKEN_AND_POP(CASE);
"true"      PUSH_VALUE_AND_POP(BOOL, true);
"false"     PUSH_VALUE_AND_POP(BOOL, false);
";"         PUSH_TOKEN_AND_POP(SEMICOLON);
":"         PUSH_TOKEN_AND_POP(COLON);
"["         PUSH_TOKEN_AND_POP(LSQUARE);
"]"         PUSH_TOKEN_AND_POP(RSQUARE);
"{"         PUSH_TOKEN_AND_POP(LBRACE);
"}"         PUSH_TOKEN_AND_POP(RBRACE);
","         PUSH_TOKEN_AND_POP(COMMA);
"."         PUSH_TOKEN_AND_POP(PERIOD);
"_"         PUSH_TOKEN_AND_POP(WILDCARD);
%{ /* Reserved operator symbols */ %}
"="         PUSH_TOKEN_AND_POP(ASSIGN);
"|"         PUSH_TOKEN_AND_POP(OR);
"?"         PUSH_TOKEN_AND_POP(QUESTION);
"<"         PUSH_TOKEN_AND_POP(LANGLE);
">"         PUSH_TOKEN_AND_POP(RANGLE);

[[:digit:]]+                        LEX_INT();
[[:digit:]]+{exp}                   LEX_FLOAT();
[[:digit:]]*"."[[:digit:]]+({exp})? LEX_FLOAT();
[[:digit:]]+"."[[:digit:]]*({exp})? LEX_FLOAT();
{nan}                               PUSH_VALUE_AND_POP(FLOAT, NAN);
{inf}                               PUSH_VALUE_AND_POP(FLOAT, INFINITY);
{str} {
    std::string str = yytext;
    str = str.substr(1, str.size()-2);
    PUSH_VALUE_AND_POP(STRING, str);
}
{id_start}{id}*              PUSH_VALUE_AND_POP(IDENT, yytext);
{op}({op}|{reserved})*       PUSH_VALUE_AND_POP(OPERATOR, yytext);
{reserved}({op}|{reserved})+ PUSH_VALUE_AND_POP(OPERATOR, yytext);

[[:blank:]]+ {
    // Ignore non-leading whitespace
    STEP();
}

"(" {
    yy_push_state(PAREN);
    PUSH_TOKEN_AND_POP(LPAREN);
}
")" {
    PUSH_TOKEN_AND_POP(RPAREN);
}

";"[[:blank:]]*/[\n\r;] {
    // Ignore ';'s that are immediately followed by a line break or another ';'
    STEP();
}
";"[[:blank:]]* {
    PUSH_TOKEN_AND_POP(SEMICOLON);
}

[\n\r]+/[[:blank:]] {
    auto begin = driver.location->begin;
    LINE();
    driver.location->begin = begin;
    PUSH_TOKEN_AND_POP(NEWLINE);
}

[\n\r]+/. {
    auto begin = driver.location->begin;
    LINE();
    driver.location->begin = begin;
    PUSH_TOKEN(NEWLINE);
    if (driver.applyIndent(0)) {
        throw Parser::syntax_error(LOC, "indentation does not match any previous indentation levels");
    }
    if (yy_flex_debug) {
        std::cerr << "--applied indent of 0" << std::endl;
    }
    POP_TOKEN();
}

[\n\r]+ {
    LINE();
}

. {
    std::stringstream ss;
    ss << "invalid character: ";
    if (std::isprint(static_cast<unsigned char>(*yytext))) {
        ss << "'" << *yytext << "'";
    } else {
        char c = *yytext;
        switch (c) {
            case '\a': ss << R"('\a')"; break;
            case '\b': ss << R"('\b')"; break;
            case '\f': ss << R"('\f')"; break;
            case '\v': ss << R"('\v')"; break;
            default:
                ss << "'0x" << std::hex << std::uppercase;
                if (c < 0) {
                    ss << static_cast<int>(c + 256);
                } else {
                    ss << static_cast<int>(c);
                }
                ss << "'";
        }
    }
    throw yy::Parser::syntax_error(
        LOC,
        ss.str()
    );
}

<<EOF>> {
    if (!driver.tokenQ.empty()) {
        // If the last line of the program doesn't end in a line break, insert one.
        auto backType = driver.tokenQ.back().type_get();
        if (backType != Parser::symbol_kind_type::S_NEWLINE) {
            PUSH_TOKEN_AND_POP(NEWLINE);
        }
        POP_TOKEN();
    }
    while (driver.indentStack.size() > 1) {
        driver.indentStack.pop();
        PUSH_TOKEN(OUTDENT);
        PUSH_TOKEN(NEWLINE);
    }
    if (!driver.tokenQ.empty()) {
        // POP_TOKEN() will never pop the last token in the queue, do it manually
        auto tok = std::move(driver.tokenQ.front());
        driver.tokenQ.pop();
        if (yy_flex_debug) {
            std::cerr << "--popping \"" << tok.name() << "\" (";
            if (tok.location.begin.filename)
                std::cerr << *tok.location.begin.filename << ":";
            std::cerr << tok.location.begin.line << ":";
            std::cerr << tok.location.begin.column << ")";
            std::cerr << std::endl;
        }
        return tok;
    }
    return yy::Parser::make_EOF(*driver.location);
}

%%

// This block is inserted at the bottom of scanner.yy.c

namespace yy {

Scanner::Scanner()
    : yyFlexLexer() {}

Scanner::~Scanner() {}

void
Scanner::setDebug(bool b) {
    yy_flex_debug = b;
}

}

#ifdef yylex
#undef yylex
#endif

#if defined(__clang__)
#    pragma clang diagnostic pop
#elif defined(__GNUC__) || defined(__GNUG__)
#    pragma GCC diagnostic pop
#elif defined(_MSC_VER)
#    pragma warning(pop)
#endif
